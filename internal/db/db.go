package db

import (
	encrypt "acs/pkg/crypt"
	"acs/pkg/passutils"
	"bytes"
	"errors"
	"os"

	"github.com/google/uuid"
	"github.com/gosimple/slug"
	genSlug "github.com/sethvargo/go-password/password"
	"gorm.io/gorm"
)

// Error variables
var (
	nilDB     = errors.New("nil db")
	wrongPass = errors.New("wrong pass")
	notFound  = errors.New("object not found")
)

// User model to be used on the server DB
type User struct {
	gorm.Model
	UserName     string    `json:"user_name" gorm:"not null; unique"`
	PasswordHash []byte    `json:"pass_hash" gorm:"not null"`
	Salt         []byte    `json:"salt" gorm:"not null"`
	Threads      uint8     `json:"threads" gorm:"not null"`
	URI          string    `json:"uri" gorm:"not null; unique"` // URI where the encrypted JSON will be stored
	EditedBy     uuid.UUID `json:"edited_by" gorm:"not null"`
}

// A fucntion that creates a user on the servers DB.
// editorUUID: The unique device identifier generated by the client.
func CreateUser(db *gorm.DB, userName, password string, editorUUID uuid.UUID) error {
	if db == nil {
		return nilDB
	}
	salt, err := encrypt.GenerateNonce(int(passutils.SaltLen))
	if err != nil {
		return err
	}
	passwordHash, err := passutils.Argon2ID(password, salt, passutils.Threads)
	if err != nil {
		return err
	}
	uri := slug.Make(userName) + "-" + slug.Make(genSlug.MustGenerate(8, 0, 0, false, true))
	user := User{UserName: userName, PasswordHash: passwordHash, Salt: salt, Threads: passutils.Threads, URI: uri, EditedBy: editorUUID}
	result := db.Create(&user)
	if result.Error != nil {
		return result.Error
	}
	return nil
}

// Fetches user data from the db
// If no user was found it retruns an error.
func GetUser(db *gorm.DB, userName string) (User, error) {
	if db == nil {
		return User{}, nilDB
	}
	var user User
	result := db.Find(&user, "user_name = ?", userName)
	if result.Error != nil {
		return User{}, notFound
	}
	return user, nil
}

// Changes the user password and creates a new salt
func UpdateUserPassword(db *gorm.DB, userName, oldPassword, newPassword string, editorUUID uuid.UUID) error {
	if db == nil {
		return nilDB
	}

	user, err := GetUser(db, userName)
	if err != nil {
		return err
	}

	passwordHash, err := passutils.Argon2ID(oldPassword, user.Salt, user.Threads)
	if !bytes.Equal(passwordHash, user.PasswordHash) {
		return wrongPass
	}

	salt, err := encrypt.GenerateNonce(int(passutils.SaltLen))
	if err != nil {
		return err
	}
	passwordHash, err = passutils.Argon2ID(newPassword, salt, passutils.Threads)

	result := db.Model(&user).Update("password_hash", passwordHash)
	return result.Error
}

// Marks the user as deleted on the db.
func DeleteUser(db *gorm.DB, userName, password string) error {
	user, err := GetUser(db, userName)
	if err != nil {
		return err
	}
	err = os.Remove("/users/" + user.URI)
	if err != nil {
		return err
	}
	result := db.Delete(&user)
	return result.Error
}
